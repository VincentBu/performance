#!meta

{"kernelInfo":{"defaultKernelName":"csharp","items":[{"aliases":[],"name":"csharp"}]}}

#!csharp

#!import BenchmarkAnalysis.dib

#!markdown

## Benchmark Regressions

#!csharp

List<(SeriesInfo<TData>, List<KeyValuePair<string, TData>>)> GetDataInternal<TData>(ChartType<TData> chartType,
    DataManager dataManager, List<Metric<TData>> metrics,
    Filter runFilter = null, Filter benchmarkFilter = null, IntFilter iterationFilter = null,
    ConfigIterationFilter configIterationFilter = null, Func<TData, bool> dataFilter = null, XArrangement xArrangement = null,
    NameSimplifier configNameSimplifier = null, bool includeRunName = false, Filter configFilter = null, bool debug = false)
{
    runFilter = runFilter ?? Filter.All;
    benchmarkFilter = benchmarkFilter ?? Filter.All;
    iterationFilter = iterationFilter ?? IntFilter.All;
    configFilter = configFilter ?? Filter.All;
    // configIterationFilter is not set to an empty dictionary as that would exclude everything
    dataFilter = dataFilter ?? (data => true);
    var benchmarkMap = chartType.DefaultBenchmarkMap;
    var xMetric = chartType.DefaultXMetric;
    xArrangement = xArrangement ?? XArrangements.Default;

    List<(SeriesInfo<TData>, List<KeyValuePair<string, TData>>)> dataSources = new();

    if (metrics.Count == 0)
    {
        Console.WriteLine("No metrics");
        return dataSources;
    }

    List<string> configs = dataManager.GetConfigs(runFilter: runFilter, configFilter: configFilter).Select(tuple => tuple.config).Distinct().ToList();
    if (configs.Count == 0)
    {
        Console.WriteLine("No configs afer filtering");
        return dataSources;
    }

    if (debug) Console.WriteLine("Simplify config names");
    Dictionary<string, string> configDisplayNames = null;
    string configPrefix = null;
    if (configNameSimplifier != null)
    {
        (configPrefix, configDisplayNames) = configNameSimplifier.Simplify(configs);
    }
    
    if (debug) Console.WriteLine("Prepare units");

    Dictionary<string, List<string>> benchmarkGroups = new();
    HashSet<string> benchmarkSet = new();
    foreach ((string run, string config, string benchmark) in
        dataManager.GetBenchmarks(runFilter: runFilter, configFilter: configFilter, benchmarkFilter: benchmarkFilter, iterationFilter: iterationFilter,
            configIterationFilter: configIterationFilter))
    {
        if (!benchmarkSet.Add(benchmark)) continue;

        string benchmarkGroup = (benchmarkMap != null) ? benchmarkMap(benchmark) : benchmark;
        benchmarkGroups.GetOrAdd(benchmarkGroup, new());
        benchmarkGroups[benchmarkGroup].Add(benchmark);
    }

    foreach (var (benchmarkGroup, benchmarkList) in benchmarkGroups)
    {
        if (debug) Console.WriteLine("Initialize colors");

        {
            string xlabel = xArrangement.GetNewTitle(xMetric.Title);

            string titlePrefix = chartType.GetChartTitle();
            List<string> titleParts = new();
            if (!string.IsNullOrWhiteSpace(benchmarkGroup)) titleParts.Add(benchmarkGroup);
            if (metrics.Count == 1) titleParts.Add(metrics[0].Title);
            if (configPrefix != null) titleParts.Add(configPrefix);
            else if (configs.Count == 1) titleParts.Add(configDisplayNames?.GetValueOrDefault(configs[0]) ?? configs[0]);
            string titleWithoutPrefix = string.Join(" / ", titleParts);
            string title = string.Join(" / ", titleParts.Prepend(titlePrefix));

            List<(XValue x, double? y)> firstDataPreSorted = null;
            double firstDataMin = 0;
            HashSet<XValue> firstDataSet = new();

            foreach (SeriesInfo<TData> info in
                chartType.GetSeries(dataManager, metrics, runFilter: runFilter, configFilter: configFilter, benchmarkFilter: benchmarkFilter,
                    iterationFilter: iterationFilter, configIterationFilter: configIterationFilter, benchmarkList: benchmarkList))
            {
                string colorFamilyKey = chartType.GetColorFamilyKey(info, multipleMetrics: metrics.Count > 1, includeRunName: includeRunName, multipleConfigs: configs.Count > 1,
                    configDisplayNames: configDisplayNames, multipleBenchmarks: benchmarkList.Count > 1);
                string seriesTitle = chartType.GetSeriesTitle(info, colorFamilyKey, metrics.Count > 1);
                if (debug) Console.Write($"series title: {seriesTitle}, ");

                List<KeyValuePair<string, TData>> dataSource;
                try { dataSource = chartType.GetDataSource(info, benchmarkFilter: benchmarkFilter, iterationFilter: iterationFilter,
                    configIterationFilter: configIterationFilter, dataFilter: dataFilter); }
                catch (Exception e) { Console.WriteLine($"Exception {e} processing data source for {title} / {seriesTitle}"); dataSource = null; }
                if (dataSource == null)
                {
                    Console.WriteLine($"No data for {titleWithoutPrefix} / {seriesTitle}");
                    continue;
                }

                else
                {
                    dataSources.Add((info, dataSource));
                }
            }
        }
    }

    return dataSources;
}

#!csharp

Dictionary<string, Dictionary<string, Dictionary<string, double?>>> GetBenchmarkData(DataManager dataManager, List<Metric<BenchmarkData>> metrics,
    Filter runFilter = null, Filter configFilter = null, Filter benchmarkFilter = null, IntFilter iterationFilter = null,
    ConfigIterationFilter configIterationFilter = null, Func<BenchmarkData, bool> dataFilter = null,
    Func<string, string> benchmarkMap = null, XArrangement xArrangement = null,
    NameSimplifier configNameSimplifier = null, bool includeRunName = false,
    bool display = true, bool debug = false)
{
    BenchmarksChartType chartType = new BenchmarksChartType();
    var xMetric = chartType.DefaultXMetric; 
    var result = GetDataInternal(chartType: chartType,
        dataManager: dataManager, metrics: metrics,
        runFilter: runFilter, benchmarkFilter: benchmarkFilter, iterationFilter: iterationFilter, configFilter: configFilter,
        configIterationFilter: configIterationFilter, dataFilter: dataFilter,
        xArrangement: xArrangement,
        configNameSimplifier: configNameSimplifier, includeRunName: includeRunName, debug: debug);

    Dictionary<string, Dictionary<string, Dictionary<string, double?>>> data = new();
    //foreach (var r in result)
    for (int i = 0; i < result.Count; i++)
    {
        var r = result[i];

        List<(XValue, double?)> benchmarkMetricData = null;
        try { benchmarkMetricData = r.Item2.Select(b => (x: xMetric.DoExtract((b.Key, b.Value)), y: r.Item1.Metric.DoExtract(b.Value, i))).ToList(); }
        catch { Console.WriteLine($"Exception processing data items"); benchmarkMetricData = null; } 

        // Config -> Metric -> (Benchmark, Data).
        if (benchmarkMetricData != null)
        {
            if (!data.TryGetValue(r.Item1.Config, out var configData))
            {
                data[r.Item1.Config] = configData = new();
            }

            if (!configData.TryGetValue(r.Item1.Metric.Title, out var runData))
            {
                configData[r.Item1.Metric.Title] = runData = new();
            }

            foreach (var benchmark in benchmarkMetricData)
            {
                runData[benchmark.Item1.GetName()] = benchmark.Item2;
            }
        }

        else
        {
            // TODO: Log.
        }
    }

    return data;
}

#!csharp

public record BenchmarkRegressionInfo(string benchmarkName, string metricInfo, double regressionPercentage);

// TODO: Add custom calculation.
static List<BenchmarkRegressionInfo> GetBenchmarkRegressions (
    this Dictionary<string, Dictionary<string, Dictionary<string, double?>>> data, string baselineConfig, string comparandConfig, double tolerancePercentage = 5, bool debug = false,
    Dictionary<Metric<BenchmarkData>, double> metricToleranceOverridePercentage = null)
{
    metricToleranceOverridePercentage ??= new();
    Dictionary<string, double> simplifiedMetricToleranceOverridePercentage = new();
    foreach (var metricToleranceOverride in metricToleranceOverridePercentage)
    {
        simplifiedMetricToleranceOverridePercentage[metricToleranceOverride.Key.Title] = metricToleranceOverride.Value;
    }

    List<BenchmarkRegressionInfo> regressions = new();
    double? percentDifference (double? baseline, double? comparand) => (comparand - baseline) / baseline * 100;

    // Preconditition Checks.
    if (!data.ContainsKey(baselineConfig) || !data.ContainsKey(comparandConfig))
    {
        if (debug)
        {
            Console.WriteLine($"Either {baselineConfig} or {comparandConfig} is not present in the data.");
        }

        return regressions;
    }

    // Metric -> BenchmarkData.
    var baselineData = data[baselineConfig];
    var comparandData = data[comparandConfig];

    foreach (var metricToBenchmarkData in baselineData)
    {
        string metric = metricToBenchmarkData.Key;
        if (comparandData.TryGetValue(metric, out var comparandSeries))
        {
            foreach (var b in metricToBenchmarkData.Value)
            {
                string benchmark = b.Key;
                if (!comparandSeries.TryGetValue(b.Key, out var c))
                {
                    if (debug)
                    {
                        Console.WriteLine($"Skipping comparison for {metricToBenchmarkData.Key} as one of the values is null.");
                    }
                    continue;
                }

                var diff = percentDifference(b.Value, c.Value);
                if (double.IsNaN(diff.GetValueOrDefault()) || double.IsInfinity(diff.GetValueOrDefault()))
                {
                    if (debug)
                    {
                        Console.WriteLine($"Obtained illegal diff for {b.Key} x {metricToBenchmarkData.Key} - Omitting");
                    }
                }

                // TODO: Add some sense of metric differentiation.

                // If the override exists, use it.
                if (simplifiedMetricToleranceOverridePercentage.TryGetValue(metricToBenchmarkData.Key, out var overrideValue))
                {
                    if (Math.Abs(diff.GetValueOrDefault()) > Math.Abs(overrideValue))
                    {
                        regressions.Add(new BenchmarkRegressionInfo(b.Key, metricToBenchmarkData.Key, Math.Round(diff.GetValueOrDefault(), 2)));
                    }
                }

                // Else, fall back to the default calculation.
                else if (Math.Abs(diff.GetValueOrDefault()) > Math.Abs(tolerancePercentage)) 
                {
                    regressions.Add(new BenchmarkRegressionInfo(b.Key, metricToBenchmarkData.Key, Math.Round(diff.GetValueOrDefault(), 2)));
                }
            }
        }

        else
        {
            if (debug)
            {
                Console.WriteLine($"Metric missing in comparand config: {metricToBenchmarkData.Key} -- skipping");
            }
        }
    }

    return regressions;
}

#!csharp

public static (int, double?) FindMostDifferentDataPoint(List<double?> data, double volatilityThreshold = 5)
{
    double? Abs(double? x) => x < 0 ? -x : x;
    double? volatility = (data.Max() - data.Min()) / data.Min() * 100;

    if (volatility > volatilityThreshold)
    {
        double? mostDifferentDataPoint = data.OrderByDescending(x => Abs(x.Value - data.Average(d => d))).FirstOrDefault();
        for (int i = 0; i < data.Count; i++)
        {
            if (data[i] == mostDifferentDataPoint)
            {
                return (i, volatility);
            }
        }

    }

    return (-1, volatility);
}

#!csharp

void DisplayBenchmarkSummaryWithRegressions(DataManager dm, string baselineConfigName, string comparandConfigName, List<Metric<BenchmarkData>> metrics = null, double benchmarkRegressionThreshold = 5.0,
    Filter runFilter = null, Filter configFilter = null, Filter benchmarkFilter = null, IntFilter iterationFilter = null,
    ConfigIterationFilter configIterationFilter = null, Func<BenchmarkData, bool> dataFilter = null,
    Func<string, string> benchmarkMap = null, XArrangement xArrangement = null,
    NameSimplifier configNameSimplifier = null, bool includeRunName = false,
    bool display = true, bool debug = false, Dictionary<Metric<BenchmarkData>, double> metricToleranceOverridePercentage = null)
{
    metrics ??= ML(Metrics.B.MaxMaxHeapSize, Metrics.B.MaxHeapSizeCVPerc, Metrics.B.AverageP50Latency, Metrics.B.P50LatencyCVPerc, Metrics.B.AverageRequestPerMSec, Metrics.B.RequestPerMSecCVPerc);
    var benchmarkData = 
        GetBenchmarkData(dm, metrics, runFilter, configFilter, benchmarkFilter, iterationFilter, configIterationFilter, dataFilter, benchmarkMap, xArrangement, configNameSimplifier, includeRunName, display, debug);
    List<BenchmarkRegressionInfo> regressions = 
        benchmarkData.GetBenchmarkRegressions(baselineConfig: baselineConfigName, comparandConfig: comparandConfigName, tolerancePercentage: benchmarkRegressionThreshold, debug: debug, metricToleranceOverridePercentage: metricToleranceOverridePercentage);

    HashSet<string> benchmarks = new();
    HashSet<string> metricSet = new();

    foreach (var regression in regressions)
    {
        benchmarks.Add(regression.benchmarkName);
        metricSet.Add(regression.metricInfo);
    }

    // Map metric string to Metric<Benchmark> list.
    metrics = metrics.Where(m => metricSet.Contains(m.Title)).ToList();

    TableBenchmarks(dm, metrics, configCompareInfo: new ConfigCompareInfo(baselineConfigName, comparandConfigName), 
    runFilter: runFilter, benchmarkFilter: new Filter(benchmarks), iterationFilter: iterationFilter, 
    benchmarkMap: benchmarkMap, xArrangement: xArrangement, configNameSimplifier: configNameSimplifier, includeRunName: includeRunName, display: display, debug: debug);
}

#!markdown

## Iteration

#!csharp

public record IterationDetails(string configName, int iterationNumber, Dictionary<string, double?> data);

void DisplayIterationData(DataManager dataManager, string baselineConfigName, string comparandConfigName, List<Metric<IterationData>> metrics = null,
    Filter runFilter = null, Filter benchmarkFilter = null, IntFilter iterationFilter = null,
    ConfigIterationFilter configIterationFilter = null, Func<IterationData, bool> dataFilter = null,
    Func<string, string> benchmarkMap = null, XArrangement xArrangement = null,
    NameSimplifier configNameSimplifier = null, bool includeRunName = false,
    bool display = true, bool debug = false, double volatilityThreshold = 5, Dictionary<Metric<IterationData>, double> metricVolOverridePercentage = null, Aggregation aggregation = null)
{
    metricVolOverridePercentage ??= new();
    aggregation ??= Aggregation.Average;
    IterationsChartType chartType = new IterationsChartType();
    var xMetric = chartType.DefaultXMetric; 
    metrics ??= ML(Metrics.I.Gen0Count, Metrics.I.Gen0MeanPauseMSec, 
                   Metrics.I.Gen1Count, Metrics.I.Gen1MeanPauseMSec, 
                   Metrics.I.BlockingGCCount, Metrics.I.BlockingGCMeanPauseTime, 
                   Metrics.I.BGCCount, Metrics.I.BGCMeanPauseTime, 
                   Metrics.I.TotalAllocationsMB, Metrics.I.MeanAllocPerGC, 
                   Metrics.I.PercentPauseTimeInGC, Metrics.I.MeanHeapSizeBefore, Metrics.I.MeanHeapSizeBeforeMB, 
                   Metrics.I.MaxWorkingSetMB, Metrics.I.RequestsPerMSec, Metrics.I.MeanLatencyMS, Metrics.I.NumberOfHeapCountSwitches, Metrics.I.TotalGCCount);
    var result = GetDataInternal(chartType: chartType,
        dataManager: dataManager, metrics: metrics,
        runFilter: runFilter, benchmarkFilter: benchmarkFilter, iterationFilter: iterationFilter, configFilter: new Filter( baselineConfigName, comparandConfigName ),
        configIterationFilter: configIterationFilter, dataFilter: dataFilter,
        xArrangement: xArrangement,
        configNameSimplifier: configNameSimplifier, includeRunName: includeRunName, debug: debug);

    string GetBenchmarkFromKey(string key) => key.Split('|')[1];
    string GetConfigFromKey(string key) => key.Split('|')[0];
    string GetMetricFromKey(string key) => key.Split('|')[2];
    string CreateKey(string configName, string benchmarkName, string metricName) => $"{configName}|{benchmarkName}|{metricName}";

    // Benchmark -> (Key -> IterationDetails)
    Dictionary<string, Dictionary<string, IterationDetails>> iterationDetails = new();
    Dictionary<string, List<double?>> iterationData = new();

    // Config -> Benchmark -> (Iteration -> Data).
    // For a benchmark and config -> Intravol of the iterations.

    // Display Table that's keyed on benchmarks.
    foreach (var kvp in result)
    {
        foreach (var benchmark in kvp.Item2)
        {
            if (!iterationDetails.TryGetValue(benchmark.Key, out var d))
            {
                iterationDetails[benchmark.Key] = d = new();
            }

            int? iterationNumber = kvp.Item1.Iteration.GetValueOrDefault();
            // At the iteration level, what are the details.
            string key = $"{kvp.Item1.Config}_{benchmark.Key}_{iterationNumber}";
            if (!d.TryGetValue(key, out var data))
            {
                Dictionary<string, double?> metricData = new();
                foreach (var metric in metrics)
                {
                    metricData[metric.Title] = metric.DoExtract(benchmark.Value);
                    string iterationKey = CreateKey(kvp.Item1.Config, benchmark.Key, metric.Title);

                    if (!iterationData.TryGetValue(iterationKey, out var iData))
                    {
                        iterationData[iterationKey] = iData = new();
                    }

                    iData.Add(metricData[metric.Title]);
                }

                d[key] = new IterationDetails(configName: kvp.Item1.Config, iterationNumber: iterationNumber.GetValueOrDefault(), data: metricData);
            }
        }
    }

    StringBuilder table = new();
    foreach (var benchmark in iterationDetails)
    {
        table.AppendLine($"### {benchmark.Key}");
        table.AppendLine();
        table.AppendLine("| Config | Iteration | " + string.Join(" | ", metrics.Select(m => m.Title)) + " |");
        table.AppendLine("| ------ | --------- | " + string.Join(" | ", metrics.Select(m => "------")) + " |");
        foreach (var iteration in benchmark.Value)
        {
            table.AppendLine($"| {iteration.Value.configName} | {iteration.Value.iterationNumber} | " + string.Join(" | ", iteration.Value.data.Select(d => d.Value?.ToString("F2") ?? "N/A")) + " |");
        }

        // Get Config and Benchmark Data for Metrics.
        List<Metric<BenchmarkData>> benchmarkMetrics = metrics.Select(m => Metrics.Promote(m, aggregation)).ToList();
        var baselineData = GetBenchmarkData(dataManager: dataManager, metrics: benchmarkMetrics, configFilter: new Filter(baselineConfigName),  benchmarkFilter: new Filter(benchmark.Key), iterationFilter: iterationFilter, 
        configIterationFilter: configIterationFilter, benchmarkMap: benchmarkMap, xArrangement: xArrangement, configNameSimplifier: configNameSimplifier, includeRunName: includeRunName, display: display, debug: debug);
        IEnumerable<double?> baselineAggregatedMetrics = baselineData.SelectMany(d => d.Value.Values).SelectMany(d => d.Values);
        // Add baseline agg.
        table.AppendLine($"| {baselineConfigName} | {aggregation.Title} | " + string.Join(" | ", baselineAggregatedMetrics.Select(d => d.GetValueOrDefault().ToString("N2"))) + " |");

        // Add comparand agg.
        var comparandData = GetBenchmarkData(dataManager: dataManager, metrics: benchmarkMetrics, configFilter: new Filter(comparandConfigName),  benchmarkFilter: new Filter(benchmark.Key), iterationFilter: iterationFilter, 
        configIterationFilter: configIterationFilter, benchmarkMap: benchmarkMap, xArrangement: xArrangement, configNameSimplifier: configNameSimplifier, includeRunName: includeRunName, display: display, debug: debug);
        IEnumerable<double?> comparisonAggregatedMetrics = comparandData.SelectMany(d => d.Value.Values).SelectMany(d => d.Values);
        table.AppendLine($"| {comparandConfigName} | {aggregation.Title} | " + string.Join(" | ", comparisonAggregatedMetrics.Select(d => d.GetValueOrDefault().ToString("N2"))) + " |");

        // Add comparison data.
        table.AppendLine($"| Comparison | % Diff | " + string.Join(" | ", baselineAggregatedMetrics.Zip(comparisonAggregatedMetrics, (b, c) => ((c - b) / b * 100).GetValueOrDefault().ToString("F2"))) + " |"); 
        table.AppendLine("\n");

        List<(string key, int idx, double? anomolousVal, IEnumerable<double?> allVals, double volatility)> anomalies = new();

        foreach (var iteration in iterationData.Where(gc => GetBenchmarkFromKey(gc.Key) == benchmark.Key))
        {
            double volatilityThresholdToUse = volatilityThreshold;
            var overrideKey =  metrics.FirstOrDefault(m => m.Title == GetMetricFromKey(iteration.Key));
            if (overrideKey != null && (metricVolOverridePercentage.TryGetValue(overrideKey, out var overrideVol)))
            {
                volatilityThresholdToUse = overrideVol;
            }

            (int idx, double? vol) = FindMostDifferentDataPoint(iteration.Value, volatilityThresholdToUse);
            if (idx != -1)
            {
                anomalies.Add((iteration.Key, idx, iteration.Value[idx], iteration.Value, vol.GetValueOrDefault()));  
            }
        }

        if (anomalies.Count > 0)
        {
            table.AppendLine($"### Anomalies");
            table.AppendLine();
            table.AppendLine($"| Config | Iteration | Metric | Vol % | Anomalous Value | {string.Join("|", Enumerable.Range(0, anomalies[0].allVals.Count()))} |");
            table.AppendLine("| ------ | --------- | ------ | ---------- | ----------- | " + string.Join(" | ", Enumerable.Range(0, anomalies[0].allVals.Count()).Select(i => "------")) + " |");
            foreach (var anomaly in anomalies.OrderByDescending(a => a.volatility))
            {
                string key = anomaly.key;
                string config = GetConfigFromKey(key);
                string metric = GetMetricFromKey(key);
                int iteration = anomaly.idx;
                table.AppendLine($"| {config} | {anomaly.idx} | {metric}  | {Math.Round(anomaly.volatility, 2)} | {Math.Round(anomaly.anomolousVal.GetValueOrDefault(), 2)} | {string.Join(" | ", anomaly.allVals.Select(a => a.GetValueOrDefault().ToString("N2")))} | ");
            }
        }
    }

    table.ToString().DisplayAs("text/markdown");
}

Dictionary<string, Dictionary<string, Dictionary<string, Dictionary<int, double?>>>> GetIterationData_Raw(DataManager dataManager, List<Metric<IterationData>> metrics,
    Filter runFilter = null, Filter configFilter = null, Filter benchmarkFilter = null, IntFilter iterationFilter = null,
    ConfigIterationFilter configIterationFilter = null, Func<IterationData, bool> dataFilter = null,
    Func<string, string> benchmarkMap = null, XArrangement xArrangement = null,
    NameSimplifier configNameSimplifier = null, bool includeRunName = false,
    bool display = true, bool debug = false)
{
    IterationsChartType chartType = new IterationsChartType();
    var xMetric = chartType.DefaultXMetric; 
    var result = GetDataInternal(chartType: chartType,
        dataManager: dataManager, metrics: metrics,
        runFilter: runFilter, benchmarkFilter: benchmarkFilter, iterationFilter: iterationFilter, configFilter: configFilter,
        configIterationFilter: configIterationFilter, dataFilter: dataFilter,
        xArrangement: xArrangement,
        configNameSimplifier: configNameSimplifier, includeRunName: includeRunName, debug: debug);

    Dictionary<string, Dictionary<string, Dictionary<string, Dictionary<int, double?>>>> data = new();

    //foreach (var r in result)
    for (int i = 0; i < result.Count; i++)
    {
        var r = result[i];

        List<(XValue, double?)> metricData = null;
        try { metricData = r.Item2.Select(b => (x: xMetric.DoExtract((b.Key, b.Value)), y: r.Item1.Metric.DoExtract(b.Value, i))).ToList(); }
        catch { Console.WriteLine($"Exception processing data items"); metricData = null; } 

        if (metricData != null)
        {
            // Config
            if (!data.TryGetValue(r.Item1.Config, out var configData))
            {
                data[r.Item1.Config] = configData = new();
            }

            // Metric
            if (!configData.TryGetValue(r.Item1.Metric.Title, out var m))
            {
                configData[r.Item1.Metric.Title] = m = new();
            }

            // Benchmark 
            foreach (var metric in metricData)
            {
                if (!m.TryGetValue(metric.Item1.GetName(), out var itData))
                {
                    m[metric.Item1.GetName()] = itData = new(); 
                }

                itData[r.Item1.Iteration.GetValueOrDefault()] = metric.Item2;
            }
        }

        else
        {
            // TODO: Log.
        }
    }

    return data; 
}

#!csharp

//        run |                           benchmark |  gen0 | pause |  gen1 | pause |  ngc2 | pause |   bgc | pause |    allocMB |   alloc/gc |   pct |   peakMB |   meanMB |  max mem |      rps |  latency |   hc |   gc count |
// -------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
// baseline_0 |         ConnectionCloseHttpsHttpSys |   591 |  1.26 |    81 |  0.87 |     1 |  2.85 |     0 |  0.00 |    5059.47 |       7.52 |  2.71 |    14.37 |    11.00 |    44.00 |    33.95 |     0.30 |    0 |        673 |
// baseline_1 |         ConnectionCloseHttpsHttpSys |   632 |  1.27 |    19 |  0.95 |     0 |  0.00 |     1 |  0.32 |    4899.91 |       7.52 |  2.73 |    14.10 |    12.50 |    45.00 |    32.91 |     0.31 |    0 |        652 |

#!csharp

// Top level constructor taking in dm, baseline config name, comparand config.
// Display Details func that assumes all defaults. 
// Else, fluent builder.

// Build default first and then specialize.
